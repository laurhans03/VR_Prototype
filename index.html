<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VR Prototype</title>

    <!-- A-Frame library and helper components -->
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
</head>

<body>

    <!--
  Loading message
  Visible while the scene and assets initialize. Hidden after initMenu runs.
  Purpose: give feedback to the user that the scene is loading and avoid a blank screen.
-->
    <div id="loading">Loading scene...</div>

    <!--
  Main VR scene
  adjust-avatar component is attached to the <a-scene> so the avatar logic runs every frame.
  The scene contains assets, camera rig, menu, rooms and optional hand tracking entities.
-->
    <a-scene adjust-avatar>

        <!--
      Asset container
      Preloads image and model elements before runtime. We add video and audio assets
      dynamically inside initMenu to keep the HTML compact and to support different JSON inputs.
    -->
        <a-assets>
            <img id="menu_img" src="media/menu.png">
            <img id="videoicon" src="media/videoicon.png">
            <img id="backbutton" src="media/backbutton.png">
            <a-asset-item id="avatarModel" src="models/man_sitting2.glb"></a-asset-item>
        </a-assets>

        <!--
      Camera rig
      cameraRig is the parent of the camera. The camera is controlled by the headset.
      cursorBase is a ring geometry used as a gaze cursor. The cursor is a child of the camera
      so it always appears in front of the user's view when visible.
      progressRing is a separate ring used as a circular progress indicator for fuse actions.
    -->
        <a-entity id="cameraRig" position="0 0 0">
            <a-entity id="camera" camera look-controls wasd-controls="enabled: false" raycaster="objects: .clickable">
                <!-- Base of the gaze cursor (invisible by default, shown via script) -->
                <a-entity id="cursorBase" cursor="fuse: true; fuseTimeout: 2000" position="0 0 -0.5"
                    geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
                    material="color: transparent; shader: flat">
                </a-entity>

                <!-- Progress ring (visual timer when fusing a clickable element) -->
                <a-ring id="progressRing" radius-inner="0.011" radius-outer="0.02" position="0 0 -0.49" color="#FFD700"
                    theta-start="0" theta-length="0" material="shader: flat; side: double">
                </a-ring>
            </a-entity>
        </a-entity>

        <!--
      Menu scene (default visible)
      Contains the menu background (videosphere) and a welcome text.
      The welcome text and icons are positioned in initMenu based on the camera height.
      This guarantees similar layout for headset and desktop.
    -->
        <a-entity id="menu" visible="true">
            <a-videosphere src="#menu_img" rotation="0 -102 0"></a-videosphere>
            <a-text id="welcomeText" value="Welcome! Select a video:" align="center" color="#ffffff" width="3"></a-text>
        </a-entity>

        <!--
      Rooms container
      Hidden by default. When a video room is opened the code creates an a-videosphere inside this
      container. The avatar anchor and returnZone live here because they are only needed inside rooms.
    -->
        <a-entity id="rooms" visible="false">
            <!-- Avatar anchor. Updated to follow camera position while inside rooms -->
            <a-entity id="avatarAnchor">
                <a-entity id="avatarWrapper" hide-avatar-behind rotation="0 -45 0">
                    <a-entity id="avatar" gltf-model="#avatarModel" position="-2.06 -1.3 0.16" rotation="0 0 0"
                        scale="1 1 1"></a-entity>
                </a-entity>
            </a-entity>

            <!-- Invisible floor plane under the avatar (for spatial reference only) -->
            <a-plane id="floorPlatform" position="0 -1.3 0" rotation="-90 0 0" width="3" height="3"
                material="shader: flat; color: #444444; opacity: 1.0">
            </a-plane>

            <!-- <a-circle id="floorPlatform" position="0 -1.5 0" rotation="-90 0 0" width="2" height="2"
                material="shader: flat; color: #444444; opacity: 1.0">
            </a-circle> -->

            <!-- Return zone and return button (used to go back to menu) -->
            <a-plane id="returnZone" position="0 1.375 -0.8" rotation="90 0 0" width="0.18" height="0.9"
                material="color: #00ff00; opacity: 0; transparent: true" class="clickable" visible="false"></a-plane>

            <a-image id="returnButton" src="#backbutton" position="0 1.4 -0.8" width="0.1" height="0.1" visible="true"
                material="opacity: 0.9; transparent: true"></a-image>
        </a-entity>

        <!-- Optional hand tracking entities for Meta Quest -->
        <a-entity id="leftHand" hand-tracking-controls="hand: left"></a-entity>
        <a-entity id="rightHand" hand-tracking-controls="hand: right"></a-entity>

    </a-scene>

    <script>

        // ==========================================================
        // Global references and shared state
        // These variables are used across functions and event handlers.
        // ==========================================================
        const scene = document.querySelector('a-scene');
        const menu = document.querySelector('#menu');
        const rooms = document.querySelector('#rooms');
        const cursorBase = document.querySelector('#cursorBase');
        const progressRing = document.querySelector('#progressRing');
        const returnZone = document.querySelector('#returnZone');
        const camera = document.querySelector('#camera');

        // Holds the A-Frame entity that plays the menu background music
        let menuMusicEntity = null;


        // ==========================================================
        // Avatar behaviour component: adjust-avatar
        // Purpose
        //  Keeps a sitting avatar aligned with the user's head position while inside a room.
        //  Updates the avatar anchor position every frame and slowly rotates the avatar
        //  to follow the user's head direction with smooth interpolation.
        //  Ignores large pitch movements (looking far up or down) to avoid jitter.
        // ==========================================================
        AFRAME.registerComponent('adjust-avatar', {
            init: function () {
                this.lastYRot = 0;
                this.frameCount = 0;
                this.isVR = false;
                this.smoothedPos = new THREE.Vector3();

                // Track VR mode state
                this.el.sceneEl.addEventListener('enter-vr', () => { this.isVR = true; });
                this.el.sceneEl.addEventListener('exit-vr', () => { this.isVR = false; });
            },

            tick: function () {
                const cameraEl = document.querySelector('#camera');
                const anchor = document.querySelector('#avatarAnchor');
                const rooms = document.querySelector('#rooms');
                if (!cameraEl || !anchor || !rooms.getAttribute('visible')) return;

                const cam = cameraEl.object3D;
                const anchorObj = anchor.object3D;
                if (!cam || !anchorObj) return;

                // --- Smooth position following ---
                const camPos = cam.position;
                this.smoothedPos.lerp(camPos, 0.05);

                // --- Optional offset for anchor (currently zero, could move avatar slightly) ---
                const offset = new THREE.Vector3(0, 0, 0);
                offset.applyQuaternion(cam.quaternion);

                // --- Fixed avatar height to maintain sitting posture ---
                const fixedY = 1.1;
                anchorObj.position.set(
                    this.smoothedPos.x + offset.x,
                    fixedY,
                    this.smoothedPos.z + offset.z
                );

                // --- Get head orientation ---
                const euler = new THREE.Euler().setFromQuaternion(cam.quaternion, 'YXZ');
                const yaw = euler.y;
                const pitch = THREE.MathUtils.radToDeg(euler.x);

                // --- Filter extreme pitch angles to prevent rotation while looking up/down ---
                const downMin = 30, downMax = 60;
                const upMin = -20, upMax = -45;
                let pitchFactor = 1.0;

                if (pitch > downMin) {
                    const t = Math.min((pitch - downMin) / (downMax - downMin), 1.0);
                    pitchFactor = 1.0 - t * 0.98;
                } else if (pitch < upMin) {
                    const t = Math.min((upMin - pitch) / (upMin - upMax), 1.0);
                    pitchFactor = 1.0 - t * 0.98;
                }

                // --- Smoothly apply yaw rotation ---
                if (this.isVR) {
                    this.frameCount++;
                    const updateInterval = 10;
                    if (this.frameCount % updateInterval === 0) {
                        const delta = yaw - this.lastYRot;
                        const wrapped = Math.atan2(Math.sin(delta), Math.cos(delta));
                        this.lastYRot += wrapped * 0.3 * pitchFactor;
                        anchorObj.rotation.set(0, this.lastYRot, 0);
                    }
                } else {
                    const smoothing = 0.3 * pitchFactor;
                    const delta = yaw - anchorObj.rotation.y;
                    const wrapped = Math.atan2(Math.sin(delta), Math.cos(delta));
                    anchorObj.rotation.y += wrapped * smoothing;
                }
            }
        });


        // ==========================================================
        // initMenu
        // Purpose
        //  Loads videos.json, creates video assets and builds the interactive menu.
        //  Automatically arranges menu icons in rows depending on video count.
        // ==========================================================
        async function initMenu() {
            const response = await fetch('videos.json');
            const data = await response.json();
            const assets = document.querySelector('a-assets');

            // --- Prepare video and optional music assets ---
            data.videos.forEach(video => {
                const videoEl = document.createElement('video');
                videoEl.id = `video-${video.id}`;
                videoEl.src = video.src;
                videoEl.autoplay = false;
                videoEl.loop = true;
                videoEl.playsInline = true;
                videoEl.crossOrigin = 'anonymous';

                if (video.music) {
                    videoEl.muted = true;
                    const audioEl = document.createElement('audio');
                    audioEl.id = `music-${video.id}`;
                    audioEl.src = video.music;
                    audioEl.setAttribute('preload', 'auto');
                    audioEl.crossOrigin = 'anonymous';
                    assets.appendChild(audioEl);
                } else {
                    videoEl.muted = false;
                }

                assets.appendChild(videoEl);
            });

            // --- Prepare menu background music if defined ---
            if (data.menuMusic) {
                const menuAudio = document.createElement('audio');
                menuAudio.id = 'menuMusic';
                menuAudio.src = data.menuMusic;
                menuAudio.setAttribute('preload', 'auto');
                menuAudio.crossOrigin = 'anonymous';
                assets.appendChild(menuAudio);

                menuMusicEntity = document.createElement('a-entity');
                menuMusicEntity.id = 'menuMusicEntity';
                menuMusicEntity.setAttribute('sound', 'src: #menuMusic; loop: true; volume: 0.5; autoplay: false');
                menu.appendChild(menuMusicEntity);

                // Initialize and defer playback until user interacts
                menuMusicEntity.addEventListener('sound-loaded', () => {
                    menuMusicEntity.components.sound.playSound();
                    menuMusicEntity.components.sound.stopSound();
                });

                const startMenuMusic = () => {
                    if (menuMusicEntity && menuMusicEntity.components.sound) {
                        document.querySelectorAll('[sound]').forEach(e => {
                            if (e !== menuMusicEntity && e.components.sound) e.components.sound.stopSound();
                        });
                        menuMusicEntity.components.sound.playSound();
                    }
                    window.removeEventListener('click', startMenuMusic);
                    window.removeEventListener('touchstart', startMenuMusic);
                    window.removeEventListener('mousemove', startMenuMusic);
                };
                window.addEventListener('click', startMenuMusic);
                window.addEventListener('touchstart', startMenuMusic);
                window.addEventListener('mousemove', startMenuMusic);
            }

            // --- Position the welcome text and base Y for icons based on camera height ---
            const iconsBaseY = (camera.object3D.position.y || 1.0) + 0.5;
            const welcomeTextY = iconsBaseY + 0.6;

            let welcome = document.querySelector('#welcomeText');
            if (!welcome) {
                welcome = document.createElement('a-text');
                welcome.id = 'welcomeText';
                welcome.setAttribute('value', 'Welcome');
                welcome.setAttribute('align', 'center');
                welcome.setAttribute('color', 'white');
                welcome.setAttribute('width', '3');
                menu.appendChild(welcome);
            }
            welcome.setAttribute('position', `0 ${welcomeTextY} -3`);

            // --- Calculate layout for icon grid ---
            const total = data.videos.length;
            const rowHeight = 0.8;

            // Row distribution presets for different video counts
            function getItemsPerRow(total) {
                switch (total) {
                    case 1: return [1];
                    case 2: return [2];
                    case 3: return [3];
                    case 4: return [2, 2];
                    case 5: return [3, 2];
                    case 6: return [3, 3];
                    case 7: return [4, 3];
                    case 8: return [4, 4];
                    case 9: return [3, 3, 3];
                    case 10: return [4, 3, 3];
                    case 11: return [4, 3, 4];
                    case 12: return [4, 4, 4];
                    default:
                        const maxRows = 4;
                        const rows = Math.min(maxRows, total);
                        const itemsPerRow = [];
                        const baseCount = Math.floor(total / rows);
                        let remainder = total % rows;
                        for (let i = 0; i < rows; i++) {
                            const count = baseCount + (remainder > 0 ? 1 : 0);
                            itemsPerRow.push(count);
                            if (remainder > 0) remainder--;
                        }
                        return itemsPerRow;
                }
            }

            const itemsPerRow = getItemsPerRow(total);

            // --- Build the actual menu entries ---
            let videoIndex = 0;
            for (let r = 0; r < itemsPerRow.length; r++) {
                const count = itemsPerRow[r];
                const y = iconsBaseY - r * rowHeight;
                const spacing = 1.2;
                const rowWidth = (count - 1) * spacing;
                const offsetX = -rowWidth / 2;

                for (let i = 0; i < count; i++) {
                    const video = data.videos[videoIndex++];
                    const x = offsetX + i * spacing;
                    const z = -3;

                    const entry = document.createElement('a-entity');
                    entry.classList.add('clickable', 'menu-entry');
                    entry.id = `to-${video.id}`;
                    entry.setAttribute('position', `${x} ${y} ${z}`);
                    entry.setAttribute('look-at', '[camera]');

                    // --- Icon image ---
                    const icon = document.createElement('a-image');
                    icon.setAttribute('src', '#videoicon');
                    icon.setAttribute('width', '0.45');
                    icon.setAttribute('height', '0.45');
                    icon.setAttribute('material', 'color: white; opacity: 0.9');
                    entry.appendChild(icon);

                    // --- Label below the icon ---
                    const text = document.createElement('a-text');
                    text.setAttribute('value', video.title);
                    text.setAttribute('align', 'center');
                    text.setAttribute('position', '0 -0.35 0');
                    text.setAttribute('width', '2');
                    text.setAttribute('color', 'white');
                    entry.appendChild(text);

                    menu.appendChild(entry);

                    // --- Fuse hover (gaze selection) behavior ---
                    let fuseTimeout = null;
                    entry.addEventListener('mouseenter', () => {
                        icon.setAttribute('material', 'color: yellow');
                        progressRing.setAttribute('theta-length', 0);
                        progressRing.setAttribute('animation__fill', 'property: theta-length; from:0; to:360; dur:3000; easing: easeInOutQuad');
                        fuseTimeout = setTimeout(() => openRoom(video.id), 3000);
                    });
                    entry.addEventListener('mouseleave', () => {
                        icon.setAttribute('material', 'color: white');
                        progressRing.removeAttribute('animation__fill');
                        progressRing.setAttribute('theta-length', 0);
                        clearTimeout(fuseTimeout);
                    });
                }
            }
        }


        // ==========================================================
        // showMenuState
        // Purpose
        //  Resets the scene to the main menu, hides avatar and rooms, and restarts menu music.
        // ==========================================================
        function showMenuState() {
            menu.setAttribute('visible', true);
            rooms.querySelectorAll('.room').forEach(r => r.remove());
            rooms.setAttribute('visible', false);

            document.querySelector('#avatarAnchor').setAttribute('visible', false);
            document.querySelector('#floorPlatform').setAttribute('visible', false);

            cursorBase.object3D.visible = true;
            progressRing.object3D.visible = true;
            progressRing.removeAttribute('animation__fill');
            progressRing.setAttribute('theta-length', 0);

            if (menuMusicEntity && menuMusicEntity.components.sound) {
                menuMusicEntity.components.sound.playSound();
            }
        }


        // ==========================================================
        // openRoom
        // Purpose
        //  Opens the selected video room, shows avatar and plays video (and optional music).
        // ==========================================================
        function openRoom(videoId) {
            // --- Hide menu and show room container + avatar ---
            menu.setAttribute('visible', false);
            rooms.setAttribute('visible', true);
            document.querySelector('#avatarAnchor').setAttribute('visible', true);
            document.querySelector('#floorPlatform').setAttribute('visible', true);

            // --- Stop menu music if playing ---
            if (menuMusicEntity && menuMusicEntity.components.sound) {
                menuMusicEntity.components.sound.stopSound();
            }

            // --- Hide gaze cursor and progress ring inside the room ---
            cursorBase.object3D.visible = false;
            progressRing.object3D.visible = false;

            // --- Create room entity only if it doesn't exist ---
            let room = document.querySelector(`#room-${videoId}`);
            if (!room) {
                room = document.createElement('a-entity');
                room.id = `room-${videoId}`;
                room.classList.add('room');

                // Videosphere for selected video
                const sphere = document.createElement('a-videosphere');
                sphere.setAttribute('src', `#video-${videoId}`);
                room.appendChild(sphere);

                // Optional audio for room
                const musicEl = document.querySelector(`#music-${videoId}`);
                if (musicEl) {
                    const soundEntity = document.createElement('a-entity');
                    soundEntity.id = `roomMusicEntity-${videoId}`;
                    soundEntity.setAttribute('sound', `src: #music-${videoId}; autoplay: true; loop: true; volume: 0.5`);
                    room.appendChild(soundEntity);
                }

                rooms.appendChild(room);
            } else {
                room.setAttribute('visible', 'true');

                // Restart room music if present
                const roomMusic = room.querySelector('[sound]');
                if (roomMusic && roomMusic.components.sound) {
                    roomMusic.components.sound.playSound();
                }
            }

            // --- Play the video element ---
            const videoEl = document.querySelector(`#video-${videoId}`);
            if (videoEl) {
                if (!document.querySelector(`#music-${videoId}`)) videoEl.muted = false;
                videoEl.loop = true;
                videoEl.play().catch(err => console.warn('Video konnte nicht starten', err));
            }

            // --- Show floating hint for return button ---
            const hintContainer = document.createElement('a-entity');
            hintContainer.setAttribute('id', 'exitHint');
            hintContainer.setAttribute('position', `0 0.5 -1.5`);
            hintContainer.setAttribute('look-at', '#camera');

            const bg = document.createElement('a-plane');
            bg.setAttribute('width', '2.4');
            bg.setAttribute('height', '0.35');
            bg.setAttribute('color', '#222222');
            bg.setAttribute('opacity', '0.6');
            bg.setAttribute('material', 'shader: flat');
            bg.setAttribute('position', '0 0 0');
            hintContainer.appendChild(bg);

            const hintText = document.createElement('a-text');
            hintText.setAttribute('value', 'Look 5 seconds to the returnbutton to return to menu');
            hintText.setAttribute('align', 'center');
            hintText.setAttribute('color', '#ffffff');
            hintText.setAttribute('width', '2.2');
            hintText.setAttribute('position', '0 0 0');
            hintText.setAttribute('baseline', 'center');
            hintText.setAttribute('side', 'double');
            hintContainer.appendChild(hintText);

            document.querySelector('#cameraRig').appendChild(hintContainer);

            // --- Remove hint after 6 seconds ---
            setTimeout(() => {
                if (hintContainer && hintContainer.parentNode) {
                    hintContainer.parentNode.removeChild(hintContainer);
                }
            }, 6000);
        }


        // ==========================================================
        // Return zone fuse logic
        // Purpose
        //  Handles user looking at the return button to go back to menu.
        //  Starts a 3-second timer on gaze, shows progress animation, cancels on look away.
        // ==========================================================
        let returnTimer = null;
        let progressDelayTimer = null;

        returnZone.addEventListener('mouseenter', () => {
            if (menu.getAttribute('visible')) return;

            // Start timer to return to menu
            returnTimer = setTimeout(() => { showMenuState(); }, 3000);

            // Show cursor and progress ring immediately
            progressDelayTimer = setTimeout(() => {
                cursorBase.object3D.visible = true;
                progressRing.object3D.visible = true;
                progressRing.setAttribute('animation__fill', 'property: theta-length; from:0; to:360; dur:3000; easing: easeInOutQuad');
            }, 0);
        });

        returnZone.addEventListener('mouseleave', () => {
            // Cancel timers and reset visuals
            clearTimeout(returnTimer);
            clearTimeout(progressDelayTimer);
            progressRing.removeAttribute('animation__fill');
            progressRing.setAttribute('theta-length', 0);

            if (!menu.getAttribute('visible')) {
                cursorBase.object3D.visible = false;
                progressRing.object3D.visible = false;
            }
        });


        // ==========================================================
        // Scene loaded event
        // Purpose
        //  Initialize the menu after the A-Frame scene is ready.
        // ==========================================================
        scene.addEventListener('loaded', () => {
            setTimeout(() => {
                initMenu();
                document.getElementById('loading').style.display = 'none';
            }, 100);
        });

    </script>
</body>

</html>