<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VR Prototype</title>

    <!-- A-Frame library and helper components -->
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
</head>

<body>

    <!--
  Loading message
  Visible while the scene and assets initialize. Hidden after initMenu runs.
  Purpose: give feedback to the user that the scene is loading and avoid a blank screen.
-->
    <div id="loading">Loading scene...</div>

    <!--
  Main VR scene
  adjust-avatar component is attached to the <a-scene> so the avatar logic runs every frame.
  The scene contains assets, camera rig, menu, rooms and optional hand tracking entities.
-->
    <a-scene adjust-avatar>

        <!--
      Asset container
      Preloads image and model elements before runtime. We add video and audio assets
      dynamically inside initMenu to keep the HTML compact and to support different JSON inputs.
    -->
        <a-assets>
            <img id="menu_img" src="media/menu.png">
            <img id="videoicon" src="media/videoicon.png">
            <img id="backbutton" src="media/backbutton.png">
            <a-asset-item id="avatarModel" src="models/man_sitting2.glb"></a-asset-item>
        </a-assets>

        <!--
      Camera rig
      cameraRig is the parent of the camera. The camera is controlled by the headset.
      cursorBase is a ring geometry used as a gaze cursor. The cursor is a child of the camera
      so it always appears in front of the user's view when visible.
      progressRing is a separate ring used as a circular progress indicator for fuse actions.
    -->
        <a-entity id="cameraRig" position="0 0 0">
            <a-entity id="camera" camera look-controls wasd-controls="enabled: false" raycaster="objects: .clickable">
                <!-- gaze cursor base. Default: fuse cursor, hidden or shown by script -->
                <a-entity id="cursorBase" cursor="fuse: true; fuseTimeout: 2000" position="0 0 -0.5"
                    geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
                    material="color: transparent; shader: flat">
                </a-entity>

                <!-- progress ring is rendered at the same place as cursor and animated when needed -->
                <a-ring id="progressRing" radius-inner="0.011" radius-outer="0.02" position="0 0 -0.49" color="#FFD700"
                    theta-start="0" theta-length="0" material="shader: flat; side: double">
                </a-ring>
            </a-entity>
        </a-entity>

        <!--
      Menu scene (default visible)
      Contains the menu background (videosphere) and a welcome text.
      The welcome text and icons are positioned in initMenu based on the camera height.
      This guarantees similar layout for headset and desktop.
    -->
        <a-entity id="menu" visible="true">
            <a-videosphere src="#menu_img" rotation="0 -102 0"></a-videosphere>
            <a-text id="welcomeText" value="Welcome! Select a video!" align="center" color="#ffffff" width="3"></a-text>
        </a-entity>

        <!--
      Rooms container
      Hidden by default. When a video room is opened the code creates an a-videosphere inside this
      container. The avatar anchor and returnZone live here because they are only needed inside rooms.
    -->
        <a-entity id="rooms" visible="false">
            <!-- Avatar anchor. We update its position to the camera position when a room is active -->
            <a-entity id="avatarAnchor">
                <a-entity id="avatarWrapper" hide-avatar-behind rotation="0 -45 0">
                    <a-entity id="avatar" gltf-model="#avatarModel" position="-2.06 -1.3 0.16" rotation="0 0 0"
                    scale="1 1 1"></a-entity>
            </a-entity>
        </a-entity>


            <!-- Plattform under the Avatar -->
            <a-plane id="floorPlatform" position="0 -1.3 0" rotation="-90 0 0" width="3" height="3"
                material="shader: flat; color: #444444; opacity: 1.0">
            </a-plane>

            <!-- <a-circle id="floorPlatform" position="0 -1.5 0" rotation="-90 0 0" width="2" height="2"
                material="shader: flat; color: #444444; opacity: 1.0">
            </a-circle> -->


            <a-plane id="returnZone" position="0 1.375 -0.8" rotation="90 0 0" width="0.18" height="0.9"
                material="color: #00ff00; opacity: 0; transparent: true" class="clickable" visible="false"></a-plane>
            <a-image id="returnButton" src="#backbutton" position="0 1.4 -0.8" width="0.1" height="0.1" visible="true"
                material="opacity: 0.9; transparent: true"></a-image>
        </a-entity>

        <!-- Optional hand tracking entities for Meta Quest. They do not affect the menu logic -->
        <a-entity id="leftHand" hand-tracking-controls="hand: left"></a-entity>
        <a-entity id="rightHand" hand-tracking-controls="hand: right"></a-entity>

    </a-scene>

    <script>

        // ==========================================================
        // Global references and shared state
        // These variables are used across functions and event handlers.
        // ==========================================================
        const scene = document.querySelector('a-scene');
        const menu = document.querySelector('#menu');
        const rooms = document.querySelector('#rooms');
        const cursorBase = document.querySelector('#cursorBase');
        const progressRing = document.querySelector('#progressRing');
        const returnZone = document.querySelector('#returnZone');
        const camera = document.querySelector('#camera');

        // menuMusicEntity holds the a-entity that plays menu music through A-Frame's sound component.
        // It is declared here so showMenuState and other functions can access it.
        let menuMusicEntity = null;


        // ==========================================================
        // Avatar behaviour component: adjust-avatar
        // Purpose
        //  Keeps a sitting avatar aligned with the user's head position while inside a room.
        //  It updates the avatar anchor position every frame and rotates the avatar slowly to follow
        //  the user's looking direction. The rotation is smoothed to avoid sudden jumps. This gives the
        //  impression that the user's lap and upper body remain under the headset but the avatar can
        //  gently turn when the user moves their head.
        //  The component only runs while rooms container is visible so it does not affect the menu.
        // ==========================================================

         AFRAME.registerComponent('adjust-avatar', {
            init: function () {
                this.lastYRot = 0;
                this.frameCount = 0;
                this.isVR = false;

                this.el.sceneEl.addEventListener('enter-vr', () => { this.isVR = true; });
                this.el.sceneEl.addEventListener('exit-vr', () => { this.isVR = false; });
            },

            tick: function () {
                const cameraEl = document.querySelector('#camera');
                const anchor = document.querySelector('#avatarAnchor');
                const rooms = document.querySelector('#rooms');
                if (!cameraEl || !anchor || !rooms.getAttribute('visible')) return;

                const cam = cameraEl.object3D;
                const anchorObj = anchor.object3D;
                if (!cam || !anchorObj) return;
                
                const fixedY = -1.3; // oder was bei dir passt
                anchorObj.position.set(cam.position.x, fixedY, cam.position.z);
                // anchorObj.position.copy(cam.position);

                const euler = new THREE.Euler().setFromQuaternion(cam.quaternion, 'YXZ');
                const yaw = euler.y;
                const pitch = THREE.MathUtils.radToDeg(euler.x);

                const downMin = 30;
                const downMax = 60;
                const upMin = -20;
                const upMax = -45;

                let pitchFactor = 1.0;

                if (pitch > downMin) {
                    const t = Math.min((pitch - downMin) / (downMax - downMin), 1.0);
                    pitchFactor = 1.0 - t * 0.98;
                }

                else if (pitch < upMin) {
                    const t = Math.min((upMin - pitch) / (upMin - upMax), 1.0);
                    pitchFactor = 1.0 - t * 0.98;
                }

                if (this.isVR) {
                    this.frameCount++;
                    const updateInterval = 10;
                    if (this.frameCount % updateInterval === 0) {
                        const delta = yaw - this.lastYRot;
                        const wrapped = Math.atan2(Math.sin(delta), Math.cos(delta));
                        this.lastYRot += wrapped * 0.3 * pitchFactor;
                        anchorObj.rotation.set(0, this.lastYRot, 0);
                    }
                } else {
                    const smoothing = 0.3 * pitchFactor;
                    const delta = yaw - anchorObj.rotation.y;
                    const wrapped = Math.atan2(Math.sin(delta), Math.cos(delta));
                    anchorObj.rotation.y += wrapped * smoothing;
                }
            }
        });

        // AFRAME.registerComponent('adjust-avatar', {
        //     init: function () {
        //         this.lastYRot = 0;
        //         this.frameCount = 0;
        //         this.isVR = false;

        //         this.el.sceneEl.addEventListener('enter-vr', () => { this.isVR = true; });
        //         this.el.sceneEl.addEventListener('exit-vr', () => { this.isVR = false; });
        //     },

        //     tick: function () {
        //         const cameraEl = document.querySelector('#camera');
        //         const anchor = document.querySelector('#avatarAnchor');
        //         const rooms = document.querySelector('#rooms');
        //         if (!cameraEl || !anchor || !rooms.getAttribute('visible')) return;

        //         const cam = cameraEl.object3D;
        //         const anchorObj = anchor.object3D;
        //         if (!cam || !anchorObj) return;

        //         anchorObj.position.copy(cam.position);

        //         const euler = new THREE.Euler().setFromQuaternion(cam.quaternion, 'YXZ');
        //         const yaw = euler.y;
        //         const pitch = THREE.MathUtils.radToDeg(euler.x);

        //         const downMin = 30;
        //         const downMax = 60;
        //         const upMin = -20;
        //         const upMax = -45;

        //         let pitchFactor = 1.0;

        //         if (pitch > downMin) {
        //             const t = Math.min((pitch - downMin) / (downMax - downMin), 1.0);
        //             pitchFactor = 1.0 - t * 0.98;
        //         }

        //         else if (pitch < upMin) {
        //             const t = Math.min((upMin - pitch) / (upMin - upMax), 1.0);
        //             pitchFactor = 1.0 - t * 0.98;
        //         }

        //         if (this.isVR) {
        //             this.frameCount++;
        //             const updateInterval = 10;
        //             if (this.frameCount % updateInterval === 0) {
        //                 const delta = yaw - this.lastYRot;
        //                 const wrapped = Math.atan2(Math.sin(delta), Math.cos(delta));
        //                 this.lastYRot += wrapped * 0.3 * pitchFactor;
        //                 anchorObj.rotation.set(0, this.lastYRot, 0);
        //             }
        //         } else {
        //             const smoothing = 0.3 * pitchFactor;
        //             const delta = yaw - anchorObj.rotation.y;
        //             const wrapped = Math.atan2(Math.sin(delta), Math.cos(delta));
        //             anchorObj.rotation.y += wrapped * smoothing;
        //         }
        //     }
        // });


        // ==========================================================
        // initMenu
        // Purpose
        //  Loads videos.json, creates video assets and builds the menu layout.
        //  Positions welcome text and creates clickable icons for each video.
        //  The layout is camera-aware: icon vertical center is based on the camera height so the menu
        //  appears at a comfortable height both in headset and on desktop.
        // Details
        //  - Video elements are appended to <a-assets> so A-Frame can use them as sources.
        //  - The function builds a flexible row layout using getItemsPerRow to decide how many
        //    icons to place on each row. The function supports 1-12 custom presets and a default
        //    that distributes icons evenly into up to 4 rows. Rows may contain many items if needed.
        //  - The welcome text is set once and later repositioned when the camera height is known.
        // ==========================================================
        async function initMenu() {
            const response = await fetch('videos.json');
            const data = await response.json();
            const assets = document.querySelector('a-assets');

            // --- Videos und optionale Musik vorbereiten ---
            data.videos.forEach(video => {
                const videoEl = document.createElement('video');
                videoEl.id = `video-${video.id}`;
                videoEl.src = video.src;
                videoEl.autoplay = false;
                videoEl.loop = true;
                videoEl.playsInline = true;
                videoEl.crossOrigin = 'anonymous';

                if (video.music) {
                    videoEl.muted = true; // stumm, da separate Musik
                    const audioEl = document.createElement('audio');
                    audioEl.id = `music-${video.id}`;
                    audioEl.src = video.music;
                    audioEl.setAttribute('preload', 'auto');
                    audioEl.crossOrigin = 'anonymous';
                    assets.appendChild(audioEl);
                } else {
                    videoEl.muted = false; // Originalton nutzen
                }

                assets.appendChild(videoEl);
            });

            // --- MenuMusic vorbereiten ---
            if (data.menuMusic) {
                const menuAudio = document.createElement('audio');
                menuAudio.id = 'menuMusic';
                menuAudio.src = data.menuMusic;
                menuAudio.setAttribute('preload', 'auto');
                menuAudio.crossOrigin = 'anonymous';
                assets.appendChild(menuAudio);

                menuMusicEntity = document.createElement('a-entity');
                menuMusicEntity.id = 'menuMusicEntity';
                menuMusicEntity.setAttribute('sound', 'src: #menuMusic; loop: true; volume: 0.5; autoplay: false');
                menu.appendChild(menuMusicEntity);

                // AudioContext initialisieren
                menuMusicEntity.addEventListener('sound-loaded', () => {
                    menuMusicEntity.components.sound.playSound();
                    menuMusicEntity.components.sound.stopSound();
                });

                // Erst nach User-Interaktion starten
                const startMenuMusic = () => {
                    if (menuMusicEntity && menuMusicEntity.components.sound) {
                        // Vorher alle anderen Sounds stoppen
                        document.querySelectorAll('[sound]').forEach(e => {
                            if (e !== menuMusicEntity && e.components.sound) {
                                e.components.sound.stopSound();
                            }
                        });
                        menuMusicEntity.components.sound.playSound();
                    }
                    window.removeEventListener('click', startMenuMusic);
                    window.removeEventListener('touchstart', startMenuMusic);
                    window.removeEventListener('mousemove', startMenuMusic);
                };
                window.addEventListener('click', startMenuMusic);
                window.addEventListener('touchstart', startMenuMusic);
                window.addEventListener('mousemove', startMenuMusic);
            }

            // Determine a comfortable vertical base for the icons based on camera height
            // We add a small offset so the icons sit slightly below the eyes when seated
            const iconsBaseY = (camera.object3D.position.y || 1.0) + 0.5; // center of icon grid
            const welcomeTextY = iconsBaseY + 0.6; // welcome text appears above the icons

            // Ensure the welcome text element exists and position it
            let welcome = document.querySelector('#welcomeText');
            if (!welcome) {
                welcome = document.createElement('a-text');
                welcome.id = 'welcomeText';
                welcome.setAttribute('value', 'Welcome');
                welcome.setAttribute('align', 'center');
                welcome.setAttribute('color', 'white');
                welcome.setAttribute('width', '3');
                menu.appendChild(welcome);
            }
            welcome.setAttribute('position', `0 ${welcomeTextY} -3`);

            // Layout calculation
            const total = data.videos.length;
            const rowHeight = 0.8; // vertical spacing between rows

            // getItemsPerRow returns an array where each element is the number of icons on that row
            // The function is tuned to provide the custom presets you requested for 1..12 icons
            // and to produce a reasonable distribution for larger numbers while keeping a maximum of 4 rows.
            function getItemsPerRow(total) {
                switch (total) {
                    case 1: return [1];
                    case 2: return [2];
                    case 3: return [3];
                    case 4: return [2, 2];
                    case 5: return [3, 2];
                    case 6: return [3, 3];
                    case 7: return [4, 3];
                    case 8: return [4, 4];
                    case 9: return [3, 3, 3];
                    case 10: return [4, 3, 3];
                    case 11: return [4, 3, 4];
                    case 12: return [4, 4, 4];
                    default:
                        // For totals above 12 distribute items into up to 4 rows.
                        // Rows can contain many items. We compute a balanced distribution where
                        // the counts differ by at most one between rows.
                        const maxRows = 4;
                        const rows = Math.min(maxRows, total);
                        const itemsPerRow = [];
                        const baseCount = Math.floor(total / rows);
                        let remainder = total % rows;
                        for (let i = 0; i < rows; i++) {
                            const count = baseCount + (remainder > 0 ? 1 : 0);
                            itemsPerRow.push(count);
                            if (remainder > 0) remainder--;
                        }
                        return itemsPerRow;
                }
            }

            const itemsPerRow = getItemsPerRow(total);

            // Create rows and icons
            const rowPositions = [];
            let videoIndex = 0;

            for (let r = 0; r < itemsPerRow.length; r++) {
                const count = itemsPerRow[r];
                const y = iconsBaseY - r * rowHeight; // vertical position for this row
                const spacing = 1.2; // horizontal spacing between icons

                // compute centered x positions for this row
                const rowWidth = (count - 1) * spacing;
                const offsetX = -rowWidth / 2;
                const xPositions = [];

                for (let i = 0; i < count; i++) {
                    xPositions.push(offsetX + i * spacing);
                }
                rowPositions.push(xPositions);

                // create entity for each icon and a small label below it
                for (let i = 0; i < count; i++) {
                    const video = data.videos[videoIndex++];
                    const x = xPositions[i];
                    const z = -3; // distance from camera

                    const entry = document.createElement('a-entity');
                    entry.classList.add('clickable', 'menu-entry');
                    entry.id = `to-${video.id}`;
                    entry.setAttribute('position', `${x} ${y} ${z}`);
                    entry.setAttribute('look-at', '[camera]'); // ensure icons face the camera

                    const icon = document.createElement('a-image');
                    icon.setAttribute('src', '#videoicon');
                    icon.setAttribute('width', '0.45');
                    icon.setAttribute('height', '0.45');
                    icon.setAttribute('material', 'color: white; opacity: 0.9');
                    entry.appendChild(icon);

                    const text = document.createElement('a-text');
                    text.setAttribute('value', video.title);
                    text.setAttribute('align', 'center');
                    text.setAttribute('position', '0 -0.35 0');
                    text.setAttribute('width', '2');
                    text.setAttribute('color', 'white');
                    entry.appendChild(text);

                    menu.appendChild(entry);

                    // Fuse hover logic
                    let fuseTimeout = null;
                    entry.addEventListener('mouseenter', () => {
                        // Highlight the icon and start the circular progress animation for 3 seconds
                        icon.setAttribute('material', 'color: yellow');
                        progressRing.setAttribute('theta-length', 0);
                        progressRing.setAttribute('animation__fill', 'property: theta-length; from:0; to:360; dur:3000; easing: easeInOutQuad');
                        fuseTimeout = setTimeout(() => openRoom(video.id), 3000);
                    });
                    entry.addEventListener('mouseleave', () => {
                        // Cancel fuse and reset visuals
                        icon.setAttribute('material', 'color: white');
                        progressRing.removeAttribute('animation__fill');
                        progressRing.setAttribute('theta-length', 0);
                        clearTimeout(fuseTimeout);
                    });
                }
            }

        }


        // ==========================================================
        // showMenuState
        // Purpose
        //  Reset the scene to the menu state. Remove room entities, hide the avatar
        //  and ensure the cursor and progress ring are visible in the menu.
        // Details
        //  If menu music is available the function attempts to restart playback.
        // ==========================================================
        function showMenuState() {
            menu.setAttribute('visible', true);
            // Remove existing rooms to free memory and reset state
            rooms.querySelectorAll('.room').forEach(r => r.remove());
            rooms.setAttribute('visible', false);

            document.querySelector('#avatarAnchor').setAttribute('visible', false);
            document.querySelector('#floorPlatform').setAttribute('visible', false);

            // Make the gaze cursor and ring visible while the user is in the menu
            cursorBase.object3D.visible = true;
            progressRing.object3D.visible = true;
            progressRing.removeAttribute('animation__fill');
            progressRing.setAttribute('theta-length', 0);

            // Restart menu music if entity exists
            if (menuMusicEntity && menuMusicEntity.components.sound) {
                menuMusicEntity.components.sound.playSound();
            }
        }


        // ==========================================================
        // openRoom
        // Purpose
        //  Show a videosphere for the selected video and prepare room state.
        //  This function hides the menu, shows the avatar anchor and stops menu music.
        // Details
        //  The function creates a room entity with a videosphere and optional sound entity for
        //  background music. The actual HTML video element is played if ready.
        // ==========================================================
        function openRoom(videoId) {
            menu.setAttribute('visible', false);
            rooms.setAttribute('visible', true);
            document.querySelector('#avatarAnchor').setAttribute('visible', true);
            document.querySelector('#floorPlatform').setAttribute('visible', true);

            // Stop menu music safely
            if (menuMusicEntity && menuMusicEntity.components.sound) {
                menuMusicEntity.components.sound.stopSound();
            }

            // Hide gaze cursor and progress ring inside the room
            cursorBase.object3D.visible = false;
            progressRing.object3D.visible = false;


            // Create room only once and reuse later
            let room = document.querySelector(`#room-${videoId}`);
            if (!room) {
                room = document.createElement('a-entity');
                room.id = `room-${videoId}`;
                room.classList.add('room');
                const sphere = document.createElement('a-videosphere');
                sphere.setAttribute('src', `#video-${videoId}`);
                room.appendChild(sphere);

                // If an audio asset for the room exists create a sound entity that auto plays
                const musicEl = document.querySelector(`#music-${videoId}`);
                if (musicEl) {
                    const soundEntity = document.createElement('a-entity');
                    soundEntity.id = `roomMusicEntity-${videoId}`;
                    soundEntity.setAttribute('sound', `src: #music-${videoId}; autoplay: true; loop: true; volume: 0.5`);
                    room.appendChild(soundEntity);
                }
                rooms.appendChild(room);
            } else {
                room.setAttribute('visible', 'true');
                // Raum-Musik erneut starten, falls vorhanden
                const roomMusic = room.querySelector('[sound]');
                if (roomMusic && roomMusic.components.sound) {
                    roomMusic.components.sound.playSound();
                }
            }

            const videoEl = document.querySelector(`#video-${videoId}`);
            if (videoEl) {
                if (!document.querySelector(`#music-${videoId}`)) {
                    videoEl.muted = false; // Originalton
                }
                videoEl.loop = true;
                videoEl.play().catch(err => console.warn('Video konnte nicht starten', err));
            }


            // Show a short floating hint that informs the user how to return
            const hintContainer = document.createElement('a-entity');
            hintContainer.setAttribute('id', 'exitHint');
            hintContainer.setAttribute('position', `0 0.5 -1.5`);
            hintContainer.setAttribute('look-at', '#camera');

            const bg = document.createElement('a-plane');
            bg.setAttribute('width', '2.4');
            bg.setAttribute('height', '0.35');
            bg.setAttribute('color', '#222222');
            bg.setAttribute('opacity', '0.6');
            bg.setAttribute('material', 'shader: flat');
            bg.setAttribute('position', '0 0 0');
            hintContainer.appendChild(bg);

            const hintText = document.createElement('a-text');
            hintText.setAttribute('value', 'Look 5 seconds to the returnbutton to return to menu');
            hintText.setAttribute('align', 'center');
            hintText.setAttribute('color', '#ffffff');
            hintText.setAttribute('width', '2.2');
            hintText.setAttribute('position', '0 0 0');
            hintText.setAttribute('baseline', 'center');
            hintText.setAttribute('side', 'double');
            hintContainer.appendChild(hintText);

            document.querySelector('#cameraRig').appendChild(hintContainer);

            // Remove the hint after 4 seconds so it does not stay forever
            setTimeout(() => {
                if (hintContainer && hintContainer.parentNode) {
                    hintContainer.parentNode.removeChild(hintContainer);
                }
            }, 6000);
        }


        // ==========================================================
        // Return zone fuse logic
        // Purpose
        //  The user looks into the returnButton to go back to the menu.
        //  Behavior:
        //   - As soon as the user enters the zone the 5 second return timer starts.
        //   - The cursor and progress ring remain hidden for the first 2 seconds.
        //   - At t = 2s the cursor and visible progress animation appear and run for the remaining 3s.
        //   - If the user looks away before 5s both timers are cancelled and visuals are reset.
        // ==========================================================
        let returnTimer = null;
        let progressDelayTimer = null;

        returnZone.addEventListener('mouseenter', () => {
            if (menu.getAttribute('visible')) return; // im Menü → abbrechen

            returnTimer = setTimeout(() => { showMenuState(); }, 3000);

            progressDelayTimer = setTimeout(() => {
                cursorBase.object3D.visible = true;
                progressRing.object3D.visible = true;
                progressRing.setAttribute('animation__fill', 'property: theta-length; from:0; to:360; dur:3000; easing: easeInOutQuad');
            }, 0);
        });

        returnZone.addEventListener('mouseleave', () => {
            // Cancel timers and reset visuals
            clearTimeout(returnTimer);
            clearTimeout(progressDelayTimer);
            progressRing.removeAttribute('animation__fill');
            progressRing.setAttribute('theta-length', 0);

            if (!menu.getAttribute('visible')) {
                cursorBase.object3D.visible = false;
                progressRing.object3D.visible = false;
            }
        });


        // ==========================================================
        // Scene loaded event
        // Purpose
        //  Initialize the menu after the A-Frame scene is ready.
        //  Small timeout helps ensuring camera.object3D is available and correct when we read its position.
        // ==========================================================
        scene.addEventListener('loaded', () => {
            setTimeout(() => {
                initMenu();
                document.getElementById('loading').style.display = 'none';
            }, 100);
        });

    </script>
</body>

</html>